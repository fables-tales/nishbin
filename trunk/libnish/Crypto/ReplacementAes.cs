// ReplaceMentAes.cs created with MonoDevelop
// User: sam at 10:23Â 17/04/2009
//
// To change standard headers go to Edit->Preferences->Coding->Standard Headers
//

using System.Collections.Generic;
using System;

namespace libnish.Crypto
{
    
    
    public class ReplacementAes
    {
        
        private byte[] key;
        
        private List<byte> ExpandedKey;
        
        public ReplacementAes()
        {
            this.key = Math.math.getRandom(256).GetBytes();
            this.ExpandKey();            
        }
        
        private void SubBytes(List <byte[]> state){
            for (int i=0;i<4;i++){
                for(int j=0;j<4;j++){
                    state[i][j] = SBoxOperation(state[i][j]);
                }
            }
        }
        private void ShiftRows(List <byte[]> state){
            for (int i=0;i<4;i++){
                byte[] temp = new byte[4];
                for (int j=0;j<4;j++){
                    temp[j] = state[i][(j-i)%4];
                }
                state[i] = temp;
            }
        }
        private void MixColumns(byte[] column){
                byte[] a = new byte[4];
                byte[] b = new byte[4];
	            byte c;
	            byte h;	     
	            for(c=0;c<4;c++) {
		            a[c] = column[c];
		            h = column[c] & 0x80; /* hi bit */
		            b[c] = column[c] << 1;
		            if(h == 0x80){ 
			            b[c] ^= 0x1b; /* Rijndael's Galois field */
                    }
	            }
	            column[0] = b[0] ^ a[3] ^ a[2] ^ b[1] ^ a[1]; /* 2 * a0 + a3 + a2 + 3 * a1 */
	            column[1] = b[1] ^ a[0] ^ a[3] ^ b[2] ^ a[2]; /* 2 * a1 + a0 + a3 + 3 * a2 */
	            column[2] = b[2] ^ a[1] ^ a[0] ^ b[3] ^ a[3]; /* 2 * a2 + a1 + a0 + 3 * a3 */
	            column[3] = b[3] ^ a[2] ^ a[1] ^ b[0] ^ a[0]; /* 2 * a3 + a2 + a1 + 3 * a0 */

        }
        private void MixColumns(List<byte[]> state){
            List<byte> col1 = new List<byte>();
            byte[] col = new byte[4];
            for (int i =0;i<4;i++){
                for (int j = 0;j<4;j++){
                    col1.Add(state[j][i]);                    
                }
                col = col1.ToArray();
                MixColumns(col);
                for (int j =0;j<4;j++){
                    state[j][i] = col[j];
                }
            }
            
        }
        private byte[] Encrypt(byte[] input){
            if (input.Length != 16){
                throw new System.InvalidOperationException("you didn't pass an exact block");
            }
            byte[] rowloader = new byte[4];            
            List<byte[]> state = new List<byte[]>();
            for(int i=0;i<4;i++){
                Array.Copy(input,i*4,rowloader,0,4);
                state.Add(rowloader);
            }
            
            throw new NotImplementedException();
            
        }
        private void ExpandKey(){
            int expandedkeysize = 240;
            int currentsize = 0;
            int rconvalue = 1;
            List<byte> temp = new List<byte>(4);
            for(int i=0;i<32;i++){
                this.ExpandedKey[i] = this.key[i];
            }
            currentsize += 32;
            while (currentsize<expandedkeysize){
                
                for (int i=0;i<4;i++){
                    temp[i] = this.ExpandedKey[currentsize-4+i];
                }
                if (currentsize%32 == 0){
                    this.KeyExpansionCore(temp,rconvalue);
                    rconvalue += 1;
                }
                //this bit I just plain don't get.
                if (currentsize%32 == 16){
                    for (int i=0;i<4;i++){
                        temp[i] = SBoxOperation(temp[i]);
                    }
                }
                for(int i=0;i<4;i++){
                    this.ExpandedKey[currentsize] = (byte)(ExpandedKey[currentsize-32]^temp[i]);
                    currentsize++;
                }
                
            }
            
        }
        private void KeyExpansionCore(List<byte> Word,int iterationcount){
            Rotate(Word);
            for (int i=0;i<4;i++){
                Word[i] = SBoxOperation(Word[i]); 
            }
            Word[0] = (byte)(Word[0]^RConOperation((byte)iterationcount));
            
        }
        private void Rotate(List<byte> word){
                      
            byte last = word[0];
            word.RemoveAt(0);
            word.Add(last);
        }
        private byte RConOperation(byte input){
            byte[] Rcon = new byte[]{
                0x8d,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36,0x6c,0xd8,
                0xab,0x4d,0x9a,0x2f,0x5e,0xbc,0x63,0xc6,0x97,0x35,0x6a,0xd4,0xb3,
                0x7d,0xfa,0xef,0xc5,0x91,0x39,0x72,0xe4,0xd3,0xbd,0x61,0xc2,0x9f,
                0x25,0x4a,0x94,0x33,0x66,0xcc,0x83,0x1d,0x3a,0x74,0xe8,0xcb,0x8d,
                0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36,0x6c,0xd8,0xab,
                0x4d,0x9a,0x2f,0x5e,0xbc,0x63,0xc6,0x97,0x35,0x6a,0xd4,0xb3,0x7d,
                0xfa,0xef,0xc5,0x91,0x39,0x72,0xe4,0xd3,0xbd,0x61,0xc2,0x9f,0x25,
                0x4a,0x94,0x33,0x66,0xcc,0x83,0x1d,0x3a,0x74,0xe8,0xcb,0x8d,0x01,
                0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36,0x6c,0xd8,0xab,0x4d,
                0x9a,0x2f,0x5e,0xbc,0x63,0xc6,0x97,0x35,0x6a,0xd4,0xb3,0x7d,0xfa,
                0xef,0xc5,0x91,0x39,0x72,0xe4,0xd3,0xbd,0x61,0xc2,0x9f,0x25,0x4a,
                0x94,0x33,0x66,0xcc,0x83,0x1d,0x3a,0x74,0xe8,0xcb,0x8d,0x01,0x02,
                0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36,0x6c,0xd8,0xab,0x4d,0x9a,
                0x2f,0x5e,0xbc,0x63,0xc6,0x97,0x35,0x6a,0xd4,0xb3,0x7d,0xfa,0xef,
                0xc5,0x91,0x39,0x72,0xe4,0xd3,0xbd,0x61,0xc2,0x9f,0x25,0x4a,0x94,
                0x33,0x66,0xcc,0x83,0x1d,0x3a,0x74,0xe8,0xcb,0x8d,0x01,0x02,0x04,
                0x08,0x10,0x20,0x40,0x80,0x1b,0x36,0x6c,0xd8,0xab,0x4d,0x9a,0x2f,
                0x5e,0xbc,0x63,0xc6,0x97,0x35,0x6a,0xd4,0xb3,0x7d,0xfa,0xef,0xc5,
                0x91,0x39,0x72,0xe4,0xd3,0xbd,0x61,0xc2,0x9f,0x25,0x4a,0x94,0x33,
                0x66,0xcc,0x83,0x1d,0x3a,0x74,0xe8,0xcb
            };
            return Rcon[input];
        }
        private byte SBoxOperation(byte input){
            byte[] Sbox = new byte[]{
                0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,
                0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
                0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,
                0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
                0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,
                0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
                0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,
                0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
                0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,
                0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
                0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,
                0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
                0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,
                0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
                0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,
                0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
                0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,
                0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
                0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,
                0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
                0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,
                0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
                0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,
                0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
                0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,
                0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
                0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,
                0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
                0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,
                0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
                0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,
                0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16
            };
            return Sbox[input];
        }
                
        
        private void AddRoundKey(List<byte []> state){
            
                
        }
    }
}
